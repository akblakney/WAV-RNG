# WAV-RNG
## Introduction
Generating truly random numbers is hard. By definition, computers cannot generate random numbers since they are deterministic in nature. Instead, computers can generate *pseudorandom* numbers. Pseudorandom number generators (PRNGs) use algorithms that take a seed, or starting value, and generate sequences of numbers that approximate the (statistical) properties of sequences of random numbers. Some of these are quite good, and are used for cryptographic purposes, but they cannot be said to be *true* random number generators (TRNGs, or just RNGs). 

While PRNGs generate sequences of numbers that look random, but are in fact predetermined by the algorithm and seed, RNGs generate random numbers based on physical phenomena that are expected to be random. Examples include measuring atmospheric noise, thermal noise, and radioactive decay. In this project, we will use the former as a basis of our random number generator. Specifically, this project includes code that generates random numbers, in a variety of different formats, from .wav files containing recorded atmospheric noise. 

The rest of this document is broken up into __ sections. In the first, I give an overview of how to use the RNG driver program, `rng.py`, to generate random numbers from .wav files containing recorded atmospheric noise. Next, in the second section, I describe the methodology for the RNG in more detail. In the third section, I discuss the testing of the RNG. Finally, I end with some concluding remarks and areas of future improvement.

## Using `rng.py`
(In addition to this section, this information is available in a more condensed form which you can access by running `python3 rng.py -h`. )

Running the `rng.py` script to generate random numbers is very simple. For the most basic usage, you can run `python3 rng.py --in <input.wav>` for any input .wav file. This will print out, as a Python `bytearray`, all the random bytes generated by the .wav file. For a more readable format, you can choose from the `--ascii`, `--binary`, `--hex`, or `--digits` options to get the data in a more readable format. See examples below:

`$ python3 rng.py --in noise.wav --ascii`
output: `CfqGbj[LMa^{lK[{AA`

`$ python3 rng.py --in noise.wav --digits`
output: `60072664111942976`.

To write output to a file, you can run with the `--out` option, followed by a filename:
`$ python3 rng.py --in noise.wav --digits --out random_digits.txt`

The same can be done with any format, including raw bytes, which is the default mode of output.

Often times, a user may have a large .wav file, but may want only a portion of the random data in can generate. Firstly, to check how much random data a .wav file can generate, run,
`$python3 rng.py --in noise.wav -q`.
This runs the "query" function, which will return how many available bytes can be generated:
output: `total available bytes for noise.wav with bpb=16: 8975839`.

This tells us that our file `noise.wav` can generate about 9MB of random data. (Don't worry about the "bpb" part yet. More on that below). 

Now suppose, we want only a fraction of those raw bytes. We can specify the starting and ending bytes to print with the `-s` and `-e` flags. Start is inclusive, while end is exclusive. In mathematical notation, the range: [start, end). Without specifying either, the start position defaults to zero, and the end position defaults to the maximum given the file-size):
`$python3 rng.py --in noise.wav -s 10 -e 14 --hex`
output: `a06b1aa4`. (Note that only four bytes, in the form of hexadecimal digits, were printed out).

The above examples conclude the most basic functionality of the RNG. For the remaining steps, we will have to dive into the more technical aspects of how the random number generation happens. For a full description of the technical details, see the ~Methodology and Technical Details ~ section. But for now I will go over the basics in order to demonstrate the other options for `rng.py`

### -bpb: `bits_per_block`
Again, the full technical details of the RNG are described in the next section, but for the sake of this section, the `bits_per_block` variable dictates how many bits make up a larger "block" in the .wav file. Instead of taking all the data from the .wav file and passing it off as random data, only one bit per each block of .wav data is selected to be output in the stream of generated random data. There are technical reasons for this, as described in the next section, and the default value of `bits_per_block=16` is probably sufficient unless you're interested enough to mess around with it yourself.

### -u: `use_bit`
This variable dictates which bit, within each block of .wav data, should be used. The default value is set to `None`, which means that all bits in each block will be XOR-ed together. Alternatively, the user could use `0`, as .wav data is stored in little-endian, and therefore the least significant bit will be used. The default value of `None` should be sufficient.

### Combining with pseudorandom data
`rng.py` provides the option of combining the random data generated from the .wav file with pseudorandom data from different sources. The two sources that are currently available are the Python secrets module, with associated flag `--secrets` and pseudorandom data generated from grc.com/passwords.htm (Gibson Research Corporation) with `--grc`. Additionally, both can be selected, and all three sources of (pseudo)randomness will be used. The method of combining the random data is with the XOR function, which is discussed in more detail in the next section. Also note that, when using `--grc`, a maximum of 32 bytes can be requested, as getting larger amounts of data would require spam-requesting the site which I do not want to encourage. Examples:

`$ python3 rng.py --in noise.wav -s 0 -e 6 --secrets --hex`
output: `ae2f0ae08656`

Also, you can choose to run `rng.py` without a .wav file at all! (Although this kind of defeats the purpose of this project...). When doing this, however, you will need to specify the number of bytes, and you will have to choose the secrets and/or grc modes:

`$python3 rng.py --secrets --num_bytes 10 --digits`.

## Methodology and Technical Details
### Intuition
The methodology for this RNG was greatly inspired by Jeremy Triplett in his [medium post](https://jeremytriplett06.medium.com/using-atmospheric-noise-to-generate-true-random-numbers-dc820ac9452d) on the topic. As such, anyone who is interested in my methodology should read his overview. Additionally, his provided links to information about the [WAV](http://soundfile.sapp.org/doc/WaveFormat/) file format will be useful to anyone pursuing a similar project, or just trying to understand the details here. Another resource worth mentioning is random.org, a site that provides random data generated by atmospheric noise free of charge (up to a point). The site also has plenty of good reading material about randomness and the statistics of it all.

The basic idea behind the RNG is this: the waveform of [atmospheric noise](https://en.wikipedia.org/wiki/Atmospheric_noise), which is after all radio noise caused by natural atmospheric processes, should be random. The way that this waveform is captured in a .wav file is by a series of 16-bit samples. Basically, the data of a .wav file is a series of 16-bit numbers that describe the wave at different points in time. 

You might think that since the waveform of atmospheric noise looks pretty random, and the .wav data essentially captures that waveform in a series of 16-bit integers, we can just take all the data in the .wav file and pass it off as random. This is problematic, however, due to the way binary encoding works. In particular, since these integers are encoded in binary, some of the bits are more significant than others and are bound to vary more than others in subsequent samples of the .wav file. (Another problem is the fact that .wav files have a 44-byte header. But this is easily remedied by simply skipping over those bytes).

To understand this, consider an example. Suppose we are measuring some sort of physical quantity over time. At a certain time, `t_0`, the quantity takes on the value 7378267 units. Over a short period of time, until, say `t_1`, we expect the quantity to vary randomly in some direction, but the magnitude of that variation might not be very big. As an example, for a series of times, we might measure 7378382 units, then 7412868, then, 7351467, and so on. The variation from each sample to the next seems random, and yet the numbers taken in their entirety don't: namely because they don't vary enough to change the most significant digit (7), and hardly the second most significant digit (it changed from 3 to 4 and back to 3). 

The same concept applies with the waveform of our atmospheric noise. The most significant digit in the binary encoding is not likely to change very much (and therefore, not a very good source of randomness) from sample to sample. The least significant digit, however, we can assume to be quite random, since the variation from one sample to the next dwarfs the magnitude of the least significant bit (which is 1 in binary). Therefore, from each 16-bit sample, we will only grab the least significant bit and add it to our randomly generated sample. We can also think of this least significant bit as an indicator of whether the waveform is even or odd at a given point in time. Since we are dealing with such large magnitudes (16 bits gives a total magnitude of 2^16, which is over 60,000), whether the waveform at a given point in time is even or odd should be random.

### `bits_per_block` and `use_bit`

This is where the `bits_per_block` variable mentioned earlier in this document fits in. The default value is set to 16 bits, which means that one bit per every 16-bit integer in the .wav file is taken as a random bit. Users can specify a larger value for this variable, as long as it is a multiple of 16, to essentially skip over different blocks. For example, setting `-bpb 32` sets the `bits_per_block` variable to 32, which means that now we are only extracting one random bit from every *two* 16-bit integers in the .wav file. As mentioned earlier, if the `use_bit` variable is not set, all of these 32 bits will be XOR-ed together to produce our random bit. If a value between 0 and 32—i.e., [0, 32)—is chosen, then that bit will be used in every group of 32 bits in the .wav file. Therefore, setting `-bpb 32 -u 0` would use the 0th bit of every other 16-bit integers in the .wav file as a random bit.

### The *Exclusive or* operation
[Exclusive or](https://en.wikipedia.org/wiki/Exclusive_or), or XOR, is a logical operation that we can perform on two bits, or strings of bits of any length. Interested readers should take a look at the linked Wikipedia page for more details, but basically, the XOR of two bits is 1 if and only if the bits differ. That is, if two bits `a` and `b` are the same (both 0 or both 1), the XOR of `a` and `b` is 0; if they are different (one is 1 and the other is 0), their XOR is 1. 

This logical operation is relevant for us because it has some useful properties when it comes to randomness. Namely, the XOR operation preserves randomness. This means that, if I have a string of random bits (that is, generated from a random process, such that each bit is 1 with probability 0.5 and 0 with probability 0.5), and I XOR that string of bits with *any* (statistically independent) string of bits of the same length, the resulting string of bits will also be random. XOR is quite a powerful tool then: even if I XOR a string of random bits with a completely deterministic and non-random string of bits (say 11111..., i.e. a string which entirely consists of 1s), the result will still be random! There is one caveat that I mentioned above, which is that the two strings must be statistically independent, i.e., their probability distributions cannot depend on one another. Luckily, the way we are using XOR in this project adheres to this requirement.

In the previous section I talk about the `--secrets` and `--grc` options which allow the user to combine the random bits generated from the .wav file with pseudorandom bits generated in the Python secrets module and GRC's PRNG. The reason I provide this option is to increase the robustness of the RNG overall. Consider the idea that we may not be completely sure that the bits generated from the .wav files are entirely random. Perhaps the frequency we are tuning to during the recording process has a faint signal that has a pattern to it. Or perhaps the way that the waveform is being written to the .wav file has some properties that causes some patterns of bits to be more likely than others. In most instances this seems unlikely given the testing I have done on the .wav portion of the RNG, which I describe in more detail in the next section, but it is always a possibility. The option of combining the random data from the .wav portion of the RNG with other sources of pseudorandom data is a way to counter this possibility. 

As I mentioned, as long as two strings of bits are statistically independent—and here it is safe to say that the .wav data, the output of the Python secrets module, and the output of the GRC PRNG are mutually independent, satisfying this requirement—XOR-ing these bit strings together cannot eliminate any randomness that either of the bit strings already contained. In other words, if we XOR random data generated from the .wav file with pseudorandom data generated from the Python secrets module, the output will still be "just as random" as the data from the .wav file. I put "just as random" in quotes because talking about *how random* something is perhaps requires more mathematically robust language than is being used here, but the overall principle holds.

So the gist of it is, XOR-ing the random output from the .wav file with pseudorandom data from the Python secrets module (which Python claims is a cryptographically-secure pseudorandom generator (CSPRNG)) cannot "downgrade" the randomness of the data. It can only upgrade it in the event that the .wav portion of the RNG isn't functioning properly and is not working as a proper RNG. In this instance, we would be XOR-ing non-random data from the .wav generator with pseudrandom data from Python's secrets module, and we would essentially have a PRNG. So users can view this option as a sort of fail-safe against the hard-to-eliminate possibility that the .wav RNG has some imperfections. 
