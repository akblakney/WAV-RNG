'''
This file contains classes used to generate random numbers.
Generator is an abstract class with an abstract method generate()
which should populate self.data with bytearray. Contains
methods for dipslaying bytes in other formats.

MixGenerator is used to generate random bytes from .wav files.

SecretsGenerator is used to generate pseudorandom numbers from the Python
secrets module (A CSPRNG)
'''

from hashlib import sha256, sha512
from abc import ABC, abstractmethod
from x_from_bytes import digits_from_bytes, ascii_from_bytes, binary_from_bytes,\
    hex_from_bytes
from my_exception import MyException
import secrets
from grc import hex_from_grc
import os

# abstract Generator class
# contains a generate method that generates random bytes
# other methods return those bytes in different formats
class Generator(ABC):

    # calls self.generate
    def __init__(self):
        pass

    # return the generated raw bytes
    def get_bytes(self):
        return self.data
    
    # return generated bytes in ascii form
    def get_ascii(self):
        return ascii_from_bytes(self.data)

    # return generated bytes in digits form
    def get_digits(self):
        return digits_from_bytes(self.data)

    # return generated bytes in binary form
    def get_binary(self):
        return binary_from_bytes(self.data)

    # return generated bytes in hexadecimal form
    def get_hex(self):
        return hex_from_bytes(self.data)

    # abstract method
    # generate the random bytes and store in self.data
    # retrieve with get_x methods above
    @abstractmethod
    def generate(self):
        pass


# subclass of Generator
# generates random bytes via the secrets module
class SecretsGenerator(Generator):
    
    def __init__(self, num_bytes):
        self.num_bytes = num_bytes
        self.data = None
        super().__init__()

    def generate(self):
        self.data = secrets.token_bytes(self.num_bytes)


class ExtendGenerator(Generator):

    # mainly just set parameters for class and verify params
    def __init__(self, inf, start, end, header_len=100, no_sha=False, \
        extension_rounds=None, block_size=2048):

        # hard coded output of SHA-512
        self.out_size = 64

        # set/verify blocksize
        self.block_size = block_size
        if self.block_size % self.out_size != 0:
            raise MyException(
                'block size must be multiple of {}'.format(self.out_size))
        # add this because of new raw method
        if (self.block_size // 2) % self.out_size != 0:
            raise MyException(
                'block size/2 must be multiple of {}'.format(self.out_size))
        if self.block_size < self.out_size:
            raise MyException(
                'block size must be at least {}'.format(self.out_size))

        # header
        self.header_len = header_len
        if self.header_len < 100:
            raise MyException('Header length too short. Must be at least 100')
        if self.header_len % 2 != 0:
            raise MyException('Header length should be even..')

        # input file
        self.inf = inf
        try:
            self.filesize = os.path.getsize(self.inf)
        except BaseException:
            raise MyException(
                'File could not be read. Check to see path and name are correct.')

        min_size = self.block_size + self.header_len
        err_msg = 'File too small. Must be at least {} bytes'.format(min_size)
        if self.filesize < min_size:
            raise MyException(err_msg)

        # blocks, start, end pos.
        self.total_blocks = self.query()
        self.start = start
        self.end = end
        if self.end is None:
            self.end = self.total_blocks
        if self.start is None:
            self.start = 0

        # verify start/end input
        if self.start < 0 or self.start >= self.total_blocks:
            raise MyException('invalid start. must be >= 0 and < available blocks')
        if self.end < 1 or self.end > self.total_blocks:
            raise MyException('invalid end. must be > 0, and <= available blocks')
        if self.end <= self.start:
            raise MyException('start must be less than end')

        # settings
        self.no_sha = no_sha
        self.extension_rounds = extension_rounds
        if not self.extension_rounds is None and self.extension_rounds < 1:
            raise MyException('number of extension rounds must be positive int > 0')

        self.num_blocks = self.end - self.start


        self.data = None

    def generate(self):

        ret = bytearray()
        file = open(self.inf, 'rb')

        # skip header and up til start
        _ = file.read(self.header_len + self.block_size * self.start)

        # with extensions=None,
        # each iter converts self.block_size -> self.out_size bytes
        # (for here this is 1024 bytes -> 64 bytes)
        # 
        # with extensions int > 1, each iter goes
        # self.block_size -> self.out_size * extensions
        # with subsequent blocks determined by sha(seed + i) for a counter i
        for i in range(self.num_blocks):
            wav_bytes = file.read(self.block_size)

            # no extensions
            if self.extension_rounds is None:
                out_bytes = self.bytes_from_block(wav_bytes)
                assert(len(out_bytes) == self.out_size)
                ret.extend(out_bytes)
                continue
                
            # if we are here then we have extensions
            # each iter extends ret by self.out_size bytes

            # curr_in are the inputs to the hash (self.block_size)
            # courr_out are the outputs from the hash (self.out_size)
            curr_in = wav_bytes
            for j in range(self.extension_rounds):
                curr_out = self.bytes_from_block(curr_in)
                assert(len(curr_out) == self.out_size)
                ret.extend(curr_out)
                curr_in = self.extend(curr_in)  # essentially increments

        if self.extension_rounds is None:
            assert(len(ret) == self.num_blocks * self.out_size)
        else:
            assert(len(ret) == self.num_blocks * self.out_size * self.extension_rounds)

        self.data = ret
        file.close()

    # increment value by one
    def extend(self, b):
        b = bytearray(b)
        _int = int.from_bytes(b, byteorder='little')
        return (_int + 1).to_bytes(len(b), 'little')


    def process_raw(self, raw_in):

        raw_size = len(raw_in)
        assert(raw_size == self.block_size // 2)

        # extract even and odd bytes from the block
        even_bytes = bytearray([raw_in[i] for i in range(0, raw_size, 2)])
        odd_bytes =  bytearray([raw_in[i] for i in range(1, raw_size, 2)])

        assert(len(even_bytes) == len(odd_bytes))
        assert(len(even_bytes) == raw_size // 2)

        assert(len(even_bytes) % self.out_size == 0)

        # smush even_bytes and odd-bytes each down to out_size each
        num_folds = (len(even_bytes) // self.out_size)
        even_out = bytes(self.out_size)
        odd_out = bytes(self.out_size)

        for i in range(num_folds):
            even_out = bytes(a ^ b for (a, b) in zip(even_out,
                even_bytes[self.out_size * i: self.out_size * (i+1)]))
            odd_out = bytes(a ^ b for (a, b) in zip(odd_out,
                odd_bytes[self.out_size * i: self.out_size * (i+1)]))
            
        assert(len(even_out) == self.out_size)
        assert(len(odd_out) == len(even_out))

        # xor even and odd outs
        raw_out = bytes(a^b for (a, b) in zip(even_out, odd_out))
        
        assert(len(raw_out) == self.out_size)   # output for SHA-512

        return raw_out
        
    def process_hash(self, hash_in):
        hash_out = sha512(hash_in).digest()
        return hash_out


    # b is bytearray of length self.block_size
    # returns extracted random bytes of size self.out_size
    def bytes_from_block(self, b):

        assert(len(b) == self.block_size)

        # split into raw and hash portions
        hash_in = b[:self.block_size // 2]
        raw_in = b[self.block_size // 2 :]

        # do raw portion
        raw_out = self.process_raw(raw_in)
        assert(len(raw_out) == self.out_size)

        if self.no_sha:
            return raw_out

        # hash portion
        hash_out = self.process_hash(hash_in)
        assert(len(hash_out) == self.out_size)

        # xor
        ret = bytes(a ^ b for (a,b) in zip(raw_out, hash_out))

        return ret

    # gives the number of 64-byte blocks available to be generated
    def query(self):
        return (self.filesize - self.header_len) // self.block_size


# generates random bytes by xor-ing the generated bytes from one or more
# sub-generators in self.generators
# display() method prints/writes generated bytes
class BaseGenerator(Generator):

    # sets num_bytes
    # initializes self.generators
    def __init__(self):
        self.generators = []

    # adds g to self.generators
    def add_generator(self, g):
        # not sure if we want this
#        if g.num_bytes != self.num_bytes:
#            raise MyException('Added generator must have equal num_bytes')
        self.generators.append(g)

    # removes all generators and clears self.data
    def reset(self):
        self.generators = []
        self.data = None

    # Generator.generate implementation
    # set self.data according to self.generators[i].generate xor
    def generate(self):

        assert(len(self.generators) > 0)

        # generate for each
        for g in self.generators:
            if g.data is None:
                g.generate()

        ret = self.generators[0].get_bytes()
        for i in range(1,len(self.generators)):
            curr = self.generators[i].get_bytes()
            assert(len(curr) == len(ret))
            ret = bytes(a ^ b for (a, b) in zip(ret, curr))
        self.data = ret

    # writes or prints self.data in desired format
    def display(self, data_mode, outf):

        # get data to write
        write_mode = 'w'
        if data_mode is None:
            ret = self.get_bytes()
            write_mode = 'wb'
        elif data_mode == 'ascii':
            ret = self.get_ascii()
        elif data_mode == 'binary':
            ret = self.get_binary()
        elif data_mode == 'hex':
            ret = self.get_hex()
        elif data_mode == 'digits':
            ret = self.get_digits()

        # write or print
        if outf is None:
            print(ret)
        else:
            with open(outf, write_mode) as f:
                f.write(ret)        
    
