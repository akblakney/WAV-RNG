'''
This file contains classes used to generate random numbers.
Generator is an abstract class with an abstract method generate()
which should populate self.data with bytearray. Contains
methods for dipslaying bytes in other formats.

MixGenerator is used to generate random bytes from .wav files.

SecretsGenerator is used to generate pseudorandom numbers from the Python
secrets module (A CSPRNG)
'''

from hashlib import sha256, sha512
from abc import ABC, abstractmethod
from x_from_bytes import digits_from_bytes, ascii_from_bytes, binary_from_bytes,\
    hex_from_bytes
from my_exception import MyException
import secrets
from grc import hex_from_grc
import os

# abstract Generator class
# contains a generate method that generates random bytes
# other methods return those bytes in different formats
class Generator(ABC):

    # calls self.generate
    def __init__(self):
        pass
#        self.generate()

    # return the generated raw bytes
    def get_bytes(self):
        return self.data
    
    # return generated bytes in ascii form
    def get_ascii(self):
        return ascii_from_bytes(self.data)

    # return generated bytes in digits form
    def get_digits(self):
        return digits_from_bytes(self.data)

    # return generated bytes in binary form
    def get_binary(self):
        return binary_from_bytes(self.data)

    # return generated bytes in hexadecimal form
    def get_hex(self):
        return hex_from_bytes(self.data)

    # abstract method
    # generate the random bytes and store in self.data
    # retrieve with get_x methods above
    @abstractmethod
    def generate(self):
        pass


# subclass of Generator
# generates random bytes via the secrets module
class SecretsGenerator(Generator):
    
    def __init__(self, num_bytes):
        self.num_bytes = num_bytes
        self.data = None
        super().__init__()

    def generate(self):
        self.data = secrets.token_bytes(self.num_bytes)

class MixGenerator(Generator):
    # start and end give begin/ending 512 -> 64 bytes BLOCKS
    # not bytes themselves
    # e.g. start=0, end=2 will return 128 bytes,
    # which correspond to the first block 0 -> 512, and second 512 -> 2*512
    def __init__(self, inf, start, end, debug=False, header_len=100):

        # hard code const
        self.header_len = header_len
        # verify header
        if self.header_len < 100:
            raise MyException('Header length too short. Must be at least 100')
        if self.header_len % 2 != 0:
            raise MyException('Header length should be even..')
        self.block_size = 512 # hard code
        self.out_size = 64

        self.inf = inf
        self.filesize = os.path.getsize(self.inf)
        self.total_blocks = self.query()
        self.start = start
        self.end = end
        self.debug_only_raw = debug

        if self.end is None:
            self.end = self.total_blocks
        if self.start is None:
            self.start = 0

        self.num_blocks = self.end - self.start

        # verify start/end input
        if self.start < 0 or self.start >= self.total_blocks:
            raise MyException('invalid start')
        if self.end < 1 or self.end > self.total_blocks:
            raise MyException('invalid end')
        if self.end <= self.start:
            raise MyException('start must be less than end')

        self.data = None


    def generate(self):
        ret = bytearray()
        file = open(self.inf, 'rb')

        # skip 100 byte header and up til start
        _ = file.read(self.header_len + self.block_size * self.start)

        # each iter converts self.block_size -> self.out_size bytes
        # (for here this is 512 bytes -> 64 bytes)
        for i in range(self.num_blocks):
            curr_bytes = file.read(self.block_size)
            curr_bytes = self.bytes_from_block(curr_bytes)
            assert(len(curr_bytes) == self.out_size)
            ret.extend(curr_bytes)
        assert(len(ret) == self.num_blocks * self.out_size)

        self.data = ret
        file.close()

    def bytes_from_block(self, b):

        ret = bytearray()
        s1 = bytearray([b[i] for i in range(0, self.block_size, 8)])
        s2 = bytearray([b[i] for i in range(2, self.block_size, 8)])
        s3 = bytearray([b[i] for i in range(4, self.block_size, 8)])
        r = bytearray([b[i] for i in range(6, self.block_size, 8)])

        # for testing:
        if self.debug_only_raw:
            return r

        s1.extend(s2)
        s1.extend(s3)
        assert(len(s1) == 192) # input for SHA-512
        assert(len(r) == self.out_size)   # output for SHA-512:w:w

        # hash s1
        hash_out = sha512(s1).digest()
        assert(len(hash_out) == len(r))

        # xor
        ret = bytes(a ^ b for (a,b) in zip(hash_out, r))

        return ret


    # gives the number of 384/64 byte blocks available
    def query(self):
        return (self.filesize - self.header_len) // self.block_size

# generates random bytes by xor-ing the generated bytes from one or more
# sub-generators in self.generators
# display() method prints/writes generated bytes
class BaseGenerator(Generator):

    # sets num_bytes
    # initializes self.generators
    def __init__(self):
        self.generators = []

    # adds g to self.generators
    def add_generator(self, g):
        # not sure if we want this
#        if g.num_bytes != self.num_bytes:
#            raise MyException('Added generator must have equal num_bytes')
        self.generators.append(g)

    # removes all generators and clears self.data
    def reset(self):
        self.generators = []
        self.data = None

    # Generator.generate implementation
    # set self.data according to self.generators[i].generate xor
    def generate(self):

        assert(len(self.generators) > 0)

        # generate for each
        for g in self.generators:
            if g.data is None:
                g.generate()

        ret = self.generators[0].get_bytes()
        for i in range(1,len(self.generators)):
            curr = self.generators[i].get_bytes()
            assert(len(curr) == len(ret))
            ret = bytes(a ^ b for (a, b) in zip(ret, curr))
        self.data = ret

        
            

    # writes or prints self.data in desired format
    def display(self, data_mode, outf):

        # get data to write
        write_mode = 'w'
        if data_mode is None:
            ret = self.get_bytes()
            write_mode = 'wb'
        elif data_mode == 'ascii':
            ret = self.get_ascii()
        elif data_mode == 'binary':
            ret = self.get_binary()
        elif data_mode == 'hex':
            ret = self.get_hex()
        elif data_mode == 'digits':
            ret = self.get_digits()

        # write or print
        if outf is None:
            print(ret)
        else:
            with open(outf, write_mode) as f:
                f.write(ret)        
    
